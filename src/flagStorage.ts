import { pathExists, readJson, writeFile, writeJson } from 'fs-extra';
import path from 'path';

import { log } from './debugLogger';
import { Config, FeatureState, FlagsState } from './types';

/**
 * Template tag function to generate filenames with different extensions Usage:
 * fileExt`baseName`('extension')
 */
const fileExt =
  (strings: TemplateStringsArray) =>
  (ext: string): string =>
    `${strings[0]}.${ext}`;

const FILE_NAMES = {
  FEATURE_STATE_FILENAME: 'featureState.json',
  FEATURE_TYPES: fileExt`features`,
};

/** Verifies that only one type definition file exists */
export async function checkTypedefs({
  typeDefPathJavascript,
  typeDefPathTypescript,
}: {
  typeDefPathJavascript: string;
  typeDefPathTypescript: string;
}): Promise<{ jsExists: boolean; tsExists: boolean }> {
  const [jsExists, tsExists] = await Promise.all([
    pathExists(typeDefPathJavascript),
    pathExists(typeDefPathTypescript),
  ]);

  return { jsExists, tsExists };
}

/** Gets the file paths for flags and environments based on the config path */
export function getFilePaths(configPath: string): {
  featureStateFilepath: string;
  typeDefPathJavascript: string;
  typeDefPathTypescript: string;
} {
  const featureStateFilepath = path.join(configPath, FILE_NAMES.FEATURE_STATE_FILENAME);
  const typeDefPathTypescript = path.join(configPath, FILE_NAMES.FEATURE_TYPES('ts'));
  const typeDefPathJavascript = path.join(configPath, FILE_NAMES.FEATURE_TYPES('d.ts'));

  return {
    featureStateFilepath,
    typeDefPathJavascript,
    typeDefPathTypescript,
  };
}

/** Loads flags state from the given file path. */
export async function loadFeatureState(featureStateFilepath: string): Promise<FeatureState> {
  try {
    return await readJson(featureStateFilepath);
  } catch (e) {
    log(e);
    throw new Error(`Failed to load JSON from ${featureStateFilepath}. Probably not valid JSON!`);
  }
}

export async function resolveConfigPath(config: Config): Promise<string> {
  const { CONFIG_PATH } = config;
  return path.resolve(process.cwd(), CONFIG_PATH);
}

/** Saves flags state to the given file path */
export async function saveFeatureState(
  featureStateFilepath: string,
  featureState: FeatureState
): Promise<void> {
  log('writing file', { filepath: featureStateFilepath, state: featureState });

  const { environments, features } = featureState;

  const sortedFeatureState = getSortedObject({
    environments: getSortedObject(environments),
    features: getSortedObject(features),
  });

  return writeJson(featureStateFilepath, sortedFeatureState, { spaces: 2 });
}

/** Writes type definitions for the flags */
export async function writeTypeDefinitions(
  typeDefPath: string,
  flagsState: FlagsState
): Promise<void> {
  const alphabetizedTypeDefs = Object.keys(flagsState)
    .sort()
    .map((flag) => `${flag}: boolean;`)
    .join('\n\t');

  const fileContent = `
/* This file is generated by the flag editor util. Changes will be lost! */
  
export type Features = {
\t${alphabetizedTypeDefs}
};
`;

  log('writing typedef file', { filepath: typeDefPath, state: flagsState });
  return writeFile(typeDefPath, fileContent);
}

function getSortedObject<T>(obj: Record<string, T>): Record<string, T> {
  return Object.keys(obj)
    .sort()
    .reduce<Record<string, T>>(
      (output, key) => {
        output[key] = obj[key];
        return output;
      },
      {} as Record<string, T>
    );
}
